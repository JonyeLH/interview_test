/*
在C++11中
左值：可以取地址的、有名字的，一般指表达式结束后依然存在的持久对象。
右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象（将亡值或纯右值）。

- 为什么右值不能用&取地址呢？
1）对于临时对象，它可以存储于寄存器中，所以没办法用“取地址&”运算符；
2）对于（非字符串）常量，它可能被编码到机器指令的“立即数”中，所以没办法用“取地址&”运算符。

举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&a可以获取该变量的地址；
表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。

左值一定在内存中，右值有可能在内存中也有可能在寄存器中

无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。


使用引用的目的就在于减少不必要的拷贝。
右值引用和左值引用的区别：
	左值可以寻址，而右值不可以。

	左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。

	左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。


C++11对右值优化：
	1、函数返回临时对象造成不必要的拷贝操作：通过使用右值引用，右值不会在表达式结束之后就销毁了，而是会被“续命”，生命周期将会通过右值引用得以延续，和变量的声明周期一样长。
	2、通过右值引用传递临时参数：使用字面值（如1、3.15f、true），或者表达式等临时变量作为函数实参传递时，按左值引用传递参数会被编译器阻止。而进行值传递时，将产生一个和参数同等大小的副本。C++11提供了右值引用传递参数，不申请局部变量，也不会产生参数副本。
	3、模板函数中如何按照参数的实际类型进行转发

*/
#include <iostream>

using namespace std;
int getdata(int &&num);
void main() {
	int num1(5);
	int num2(10);

	/***************	常量左值引用        **************	
	左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。
	它可以接受非常量左值、常量左值、右值对其进行初始化。
	不过常量左值所引用的右值在它的“余生”中只能是只读的。
	相对地，非常量左值只能接受非常量左值对其进行初始化。
	*/
	int * const &rnum = &num1;
	//rnum = &num2;		//不能再被修改
	cout << (&rnum) <<endl;	//&rnum是一个地址 0x000000ca1a6ff838，指向num1的地{0x000000ca1a6ff7d4 {5}}
	cout << *(&rnum) << endl;	//* (&rnum)是num1的地址{0x000000ca1a6ff7d4 {5}}
	cout << ** (&rnum) << endl;	// ** (&rnum)是num1地址的内容 5


	//int &a = 2;       //左值引用绑定到右值，编译失败
	
	int b = 2;        //非常量左值
	const int &c = b; //常量左值引用绑定到非常量左值，编译通过
	const int d = 2;  //常量左值
	const int &e = c; //常量左值引用绑定到常量左值，编译通过
	const int &f = 2;  //常量左值引用绑定到右值，编程通过






	////////////////       将右值绑定到左值		   /////////////// 
	int a;
	//int &&r1 = a;       //编译失败	无法将右值绑定到左值	初始化：无法从int 转换为int&&	
	int &&r2 = std::move(a);  //编译通过	使用std::move()将左值强制转换为右值
	int &&h = 2;		//将右值绑定到左值


	int num3(5);
	int num4(10);
	///////////////    错误将右值引用绑到左值引用		///////////////// 
	//int * &rnum3 = &num3;	//报错：非常量的引用初始化必须为左值	无法从“int *”转换为“int *&”	
	//原因&num1在寄存器中，使用引用取别名是不行的，寄存器中的值在不可以取地址的		这就是所谓的左值引用和右值引用。

	///////////////    修改右值地址绑定到左值引用		///////////////// 
	int *pnum3(&num3);//将寄存器num1的地址传递给内存中的pnum，内存中就有&num1的值，
	int * &rnum3 = pnum3;//rnum是pnum的别名		此时通过一个指针在进行取别名是可以的，因为此时指针在内存中
	rnum3 = &num4;//rnumhe pnum指向同一片内存  改变了rnum就相当于改变了pnum
	cout << *pnum3 << endl;




	/////////////////     右值引用的方法		///////////////// 
	int * &&rnumm = &num1;




	/**************	  为什么要使用右值引用     **************
	右值引用在你需要使用寄存器中的值的时候可以进行右值引用。
	寄存器的刷新速度很快，没有右值引用的话就需要将寄存器中的值拷贝到内存中，在进行使用，这是很浪费时间的。
	*/
	int g = 5;
	cout << getdata(g + 1) << endl;


	system("pause");
}

int getdata(int &&num)	//int getdata(int &&num)就是直接对传进来的右值(a + 1)进行引用
{
	cout << num << endl;
	num += 10;
	return num;
}